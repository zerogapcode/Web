<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alex - Asistente de Apoyo Emocional</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* ESTILOS BASE DE PROTONLAB */
        :root {
            --bg-light: #ffffff;
            --text-light: #000000;
            --muted-light: #6b7280;
            --panel-light: #f3f4f6;
            --bg-dark: #000000;
            --text-dark: #f0f0f0;
            --muted-dark: #888888;
            --panel-dark: #1a1a1a;
            --accent-dark: #e0e0f0;
            --max-width: 1100px;
            --mono: 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
            
            --card-bg-light: rgba(255, 255, 255, 0.01);
            --card-border-light: rgba(255, 255, 255, 0.1);
            --card-shadow-light: 0 8px 32px rgba(0, 0, 0, 0.03);
            
            --card-bg-dark: rgba(0, 0, 0, 0.08);
            --card-border-dark: rgba(255, 255, 255, 0.1);
            --card-shadow-dark: 0 8px 32px rgba(0, 0, 0, 0.3);
            
            --accent-color: #4CAF50; /* Cambiado a verde para un tono m√°s calmante */
            --accent-glow: rgba(76, 175, 80, 0.3);
        }

        * {
            box-sizing: border-box;
            font-family: var(--mono);
        }

        body {
            margin: 0;
            background: var(--bg-light);
            color: var(--text-light);
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }

        body[data-theme='dark'] {
            background: var(--bg-dark);
            color: var(--text-dark);
        }

        .wrap {
            max-width: var(--max-width);
            margin: 0 auto;
            padding: 20px;
        }

        /* HEADER */
        header {
            position: fixed;
            left: 0;
            right: 0;
            top: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            transition: transform .35s ease, opacity .35s ease;
            z-index: 60;
            height: 70px;
            transform: translateZ(0);
            will-change: transform;
        }

        body[data-theme='dark'] header {
            background: rgba(0, 0, 0, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .brand .mini {
            font-weight: 700;
            font-size: 20px;
            letter-spacing: 0.12em;
            color: #000000;
            cursor: pointer;
            transition: transform 0.3s ease, color 0.3s ease;
            user-select: none;
        }

        body[data-theme='dark'] .brand .mini {
            color: var(--text-dark);
        }

        .brand .mini:hover {
            transform: scale(1.1);
        }

        /* MAIN CHAT CONTAINER - MODIFICADO PARA CHATGPT STYLE */
        main {
            padding-top: 100px;
            min-height: calc(100vh - 100px);
            display: flex;
            flex-direction: column;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid var(--card-border-light);
            background: var(--card-bg-light);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            box-shadow: var(--card-shadow-light);
            margin-bottom: 100px; /* Espacio para el input fijo */
        }

        body[data-theme='dark'] .chat-container {
            background: var(--card-bg-dark);
            border: 1px solid var(--card-border-dark);
            box-shadow: var(--card-shadow-dark);
        }

        /* CHAT HEADER */
        .chat-header {
            padding: 20px 24px;
            background: rgba(76, 175, 80, 0.1);
            border-bottom: 1px solid rgba(76, 175, 80, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        body[data-theme='dark'] .chat-header {
            background: rgba(76, 175, 80, 0.08);
            border-bottom: 1px solid rgba(76, 175, 80, 0.15);
        }

        .chat-title {
            font-weight: 600;
            font-size: 18px;
            color: var(--accent-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 500;
            background: rgba(76, 175, 80, 0.15);
            color: #4CAF50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .status-indicator.offline {
            background: rgba(244, 67, 54, 0.15);
            color: #F44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .status-indicator.connecting {
            background: rgba(255, 193, 7, 0.15);
            color: #FFC107;
            border: 1px solid rgba(255, 193, 7, 0.3);
        }

        /* CHAT MESSAGES */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            background: transparent;
            max-height: calc(100vh - 200px);
        }

        .message {
            max-width: 80%;
            padding: 14px 18px;
            border-radius: 16px;
            line-height: 1.6;
            font-size: 14px;
            animation: messageAppear 0.3s ease-out;
            position: relative;
        }

        @keyframes messageAppear {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .user-message {
            align-self: flex-end;
            background: rgba(76, 175, 80, 0.15);
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-top-right-radius: 6px;
        }

        body[data-theme='dark'] .user-message {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.4);
        }

        .assistant-message {
            align-self: flex-start;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top-left-radius: 6px;
        }

        body[data-theme='dark'] .assistant-message {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-weight: 600;
            font-size: 13px;
        }

        .message-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
            font-size: 12px;
        }

        .user-message .message-avatar {
            background: var(--accent-color);
        }

        .assistant-message .message-avatar {
            background: #2196F3;
        }

        .message-time {
            font-size: 11px;
            opacity: 0.7;
            margin-left: auto;
        }

        .message-content {
            line-height: 1.7;
        }

        /* STREAMING TEXT */
        .streaming-text {
            position: relative;
            min-height: 1.2em;
        }

        .streaming-cursor {
            display: inline-block;
            width: 3px;
            height: 1.2em;
            background: var(--accent-color);
            margin-left: 2px;
            vertical-align: middle;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* TYPING INDICATOR */
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 12px;
            width: fit-content;
            border: 1px solid rgba(76, 175, 80, 0.2);
            align-self: flex-start;
            margin: 0 20px 20px 20px;
        }

        .typing-indicator span {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-color);
            animation: typing 1.4s infinite;
        }

        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% { 
                transform: translateY(0);
                opacity: 0.6;
            }
            30% { 
                transform: translateY(-6px);
                opacity: 1;
            }
        }

        /* INPUT AREA - MODIFICADO PARA PARTE INFERIOR FIJA */
        .input-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 12px;
            align-items: flex-end;
            background: var(--bg-light);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            z-index: 50;
        }

        body[data-theme='dark'] .input-area {
            background: var(--bg-dark);
        }

        .message-input {
            flex: 1;
            padding: 14px 16px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            font-size: 14px;
            resize: none;
            outline: none;
            transition: all 0.3s;
            min-height: 50px;
            max-height: 150px;
            line-height: 1.6;
            background: rgba(255, 255, 255, 0.05);
            color: inherit;
            font-family: var(--mono);
        }

        body[data-theme='dark'] .message-input {
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.15);
        }

        .message-input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }

        .send-btn {
            padding: 0 24px;
            height: 50px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.2);
        }

        .send-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(76, 175, 80, 0.3);
        }

        .send-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.1);
        }

        /* WELCOME MESSAGE */
        .welcome-message {
            text-align: center;
            padding: 40px 20px;
            color: var(--muted-light);
            animation: welcomeFade 1s ease-out;
        }

        body[data-theme='dark'] .welcome-message {
            color: var(--muted-dark);
        }

        @keyframes welcomeFade {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .welcome-message h2 {
            color: var(--accent-color);
            margin-bottom: 12px;
            font-size: 24px;
        }

        .welcome-message p {
            font-size: 15px;
            line-height: 1.7;
            max-width: 600px;
            margin: 0 auto;
        }

        /* SCROLLBAR */
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(76, 175, 80, 0.3);
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(76, 175, 80, 0.5);
        }

        /* SERVER INFO */
        .server-info {
            font-size: 12px;
            color: var(--muted-light);
            opacity: 0.7;
        }

        body[data-theme='dark'] .server-info {
            color: var(--muted-dark);
        }

        /* THEME TOGGLE */
        .mode-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .seg {
            display: inline-flex;
            border-radius: 999px;
            overflow: hidden;
            border: 2px solid #000;
            background: rgba(0, 0, 0, 0.03);
        }

        body[data-theme='dark'] .seg {
            border-color: var(--accent-dark);
            background: rgba(255, 255, 255, 0.05);
        }

        .seg button {
            padding: 6px 10px;
            border: 0;
            background: transparent;
            font-size: 11px;
            cursor: pointer;
            transition: background .2s, color .2s;
            border-radius: 0;
            color: inherit;
            font-weight: 500;
            white-space: nowrap;
        }

        body[data-theme='dark'] .seg button {
            color: var(--text-dark);
        }

        .seg button.active {
            background: rgba(0, 0, 0, 0.08);
        }

        body[data-theme='dark'] .seg button.active {
            background: rgba(255, 255, 255, 0.15);
            color: #ffffff;
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            .wrap {
                padding: 16px;
            }
            
            .chat-container {
                height: 85vh;
                border-radius: 16px;
            }
            
            .chat-header {
                padding: 16px;
            }
            
            .chat-title {
                font-size: 16px;
            }
            
            .chat-messages {
                padding: 16px;
                max-height: calc(100vh - 180px);
            }
            
            .message {
                max-width: 90%;
                padding: 12px 16px;
            }
            
            .input-area {
                padding: 16px;
            }
            
            .send-btn {
                padding: 0 20px;
                height: 46px;
            }
            
            main {
                padding-top: 90px;
            }
        }

        /* PARALLAX PANELS - INFINITO */
        .panels{position:fixed;inset:0;pointer-events:none;overflow:hidden;z-index:-1}
        .panel{
          position:absolute;
          border-radius:8px;
          opacity:.95;
          box-shadow:0 18px 40px rgba(2,6,23,0.06);
          border:1px solid rgba(255,255,255,0.2);
          transform: translate3d(0, 0, 0);
          will-change: transform;
          backface-visibility: hidden;
          -webkit-backface-visibility: hidden;
          backdrop-filter: blur(20px) saturate(180%);
          -webkit-backdrop-filter: blur(20px) saturate(180%);
          overflow: hidden;
          transition: transform 0.1s linear;
        }
        
        .panel.color-red {
          background: rgba(255, 100, 100, 0.18);
          border-color: rgba(255, 100, 100, 0.5);
          box-shadow: 0 18px 40px rgba(255, 100, 100, 0.25);
        }
        
        .panel.color-orange {
          background: rgba(255, 165, 80, 0.18);
          border-color: rgba(255, 165, 80, 0.5);
          box-shadow: 0 18px 40px rgba(255, 165, 80, 0.25);
        }
        
        .panel.color-yellow {
          background: rgba(255, 220, 100, 0.18);
          border-color: rgba(255, 220, 100, 0.5);
          box-shadow: 0 18px 40px rgba(255, 220, 100, 0.25);
        }
        
        .panel.color-green {
          background: rgba(100, 220, 150, 0.18);
          border-color: rgba(100, 220, 150, 0.5);
          box-shadow: 0 18px 40px rgba(100, 220, 150, 0.25);
        }
        
        .panel.color-blue {
          background: rgba(100, 180, 255, 0.18);
          border-color: rgba(100, 180, 255, 0.5);
          box-shadow: 0 18px 40px rgba(100, 180, 255, 0.25);
        }
        
        .panel.color-violet {
          background: rgba(180, 120, 255, 0.18);
          border-color: rgba(180, 120, 255, 0.5);
          box-shadow: 0 18px 40px rgba(180, 120, 255, 0.25);
        }
        
        .panel.large {
          width: 280px;
          height: 140px;
          z-index: 3;
        }
        @media (min-width: 768px) {
          .panel.large {
            width: 320px;
            height: 160px;
          }
        }
        
        .panel.medium {
          width: 220px;
          height: 110px;
          z-index: 2;
          opacity: 0.85;
        }
        @media (min-width: 768px) {
          .panel.medium {
            width: 250px;
            height: 125px;
          }
        }
        
        .panel.small {
          width: 150px;
          height: 75px;
          opacity: 0.7;
          z-index: 1;
        }
        @media (min-width: 768px) {
          .panel.small {
            width: 180px;
            height: 90px;
          }
        }
        
        .panel .inner{
          padding: 10px;
          color: var(--muted-light);
          overflow: hidden;
          height: 100%;
          display: flex;
          flex-direction: column;
          justify-content: flex-start;
          font-family: var(--mono);
          font-size: 11px;
          line-height: 1.3;
        }
        
        .panel .inner .code-line {
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          width: 100%;
          font-family: var(--mono);
          font-size: 10px;
        }
        
        .typing-cursor {
          display: inline-block;
          width: 6px;
          height: 1em;
          background-color: currentColor;
          margin-left: 1px;
          animation: blink 1s infinite;
          vertical-align: middle;
        }
        
        @keyframes blink {
          0%, 50% { opacity: 1; }
          51%, 100% { opacity: 0; }
        }
        
        body[data-theme='dark'] .panel{
          color:var(--text-dark);
          box-shadow:0 18px 40px rgba(0,0,0,0.4);
        }
        
        body[data-theme='dark'] .panel.color-red {
          background: rgba(255, 100, 100, 0.12);
          border-color: rgba(255, 100, 100, 0.4);
          box-shadow: 0 18px 40px rgba(255, 100, 100, 0.25);
        }
        
        body[data-theme='dark'] .panel.color-orange {
          background: rgba(255, 165, 80, 0.12);
          border-color: rgba(255, 165, 80, 0.4);
          box-shadow: 0 18px 40px rgba(255, 165, 80, 0.25);
        }
        
        body[data-theme='dark'] .panel.color-yellow {
          background: rgba(255, 220, 100, 0.12);
          border-color: rgba(255, 220, 100, 0.4);
          box-shadow: 0 18px 40px rgba(255, 220, 100, 0.25);
        }
        
        body[data-theme='dark'] .panel.color-green {
          background: rgba(100, 220, 150, 0.12);
          border-color: rgba(100, 220, 150, 0.4);
          box-shadow: 0 18px 40px rgba(100, 220, 150, 0.25);
        }
        
        body[data-theme='dark'] .panel.color-blue {
          background: rgba(100, 180, 255, 0.12);
          border-color: rgba(100, 180, 255, 0.4);
          box-shadow: 0 18px 40px rgba(100, 180, 255, 0.25);
        }
        
        body[data-theme='dark'] .panel.color-violet {
          background: rgba(180, 120, 255, 0.12);
          border-color: rgba(180, 120, 255, 0.4);
          box-shadow: 0 18px 40px rgba(180, 120, 255, 0.25);
        }
        
        body[data-theme='dark'] .panel .inner{
          color:var(--muted-dark);
        }
        
        /* OPTIMIZACI√ìN PARA M√ìVILES: Reducir cantidad de paneles */
        @media (max-width: 768px) {
          .panel.large:nth-child(n+3) {
            display: none;
          }
          .panel.medium:nth-child(n+4) {
            display: none;
          }
          .panel.small:nth-child(n+4) {
            display: none;
          }
        }
        
        @media (prefers-reduced-motion: reduce) {
          .panel {
            transform: none !important;
          }
          
          .typing-cursor {
            animation: none;
            opacity: 1;
          }
        }
    </style>
</head>
<body>
    <header id="topbar">
        <div class="brand">
            <div class="mini" id="brandMini" onclick="window.location.href='index.html'">&lt;/&gt;</div>
        </div>
        <div class="mode-toggle">
            <div class="seg">
                <button data-mode="auto" class="active">Auto</button>
                <button data-mode="light">Claro</button>
                <button data-mode="dark">Oscuro</button>
            </div>
        </div>
    </header>

    <!-- PANELES PARALLAX -->
    <div class="panels" id="panels"></div>

    <main class="wrap">
        <div class="chat-container">
            <div class="chat-header">
                <div class="chat-title">
                    <span>ü§ó Alex - Apoyo Emocional</span>
                    <span class="server-info">llama3.2:3b</span>
                </div>
                <div class="status-indicator" id="status">Conectando...</div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="welcome-message">
                    <h2>Hola, soy Alex üëã</h2>
                    <p>Estoy aqu√≠ para ofrecerte un espacio seguro de conversaci√≥n. Puedes contarme c√≥mo te sientes, compartir tus pensamientos, o simplemente charlar. Mi objetivo es escucharte con empat√≠a y ofrecerte apoyo emocional. ¬øC√≥mo ha sido tu d√≠a hasta ahora?</p>
                </div>
            </div>

            <div class="typing-indicator" id="typingIndicator" style="display: none;">
                <span></span>
                <span></span>
                <span></span>
                <span style="margin-left: 8px; font-size: 12px; color: var(--muted-light);">Alex est√° escribiendo...</span>
            </div>
        </div>
    </main>

    <!-- INPUT AREA FIJA EN LA PARTE INFERIOR -->
    <div class="input-area">
        <textarea 
            class="message-input" 
            id="messageInput" 
            placeholder=""
            rows="1"
        ></textarea>
        <button class="send-btn" id="sendBtn" onclick="sendMessage()">
            <span>Enviar</span>
        </button>
    </div>

    <script>
        // ========================================
        // CONFIGURACI√ìN ACTUALIZADA
        // ========================================
        const OLLAMA_SERVER_URL = 'https://liberatory-adeline-unlaudable.ngrok-free.dev';
        const ASSISTANT_TYPE = 'amable'; // Debe coincidir exactamente con el servidor
        
        console.log('üöÄ Alex - Asistente de Apoyo Emocional');
        console.log('üåê URL del backend:', OLLAMA_SERVER_URL);
        console.log('ü§ñ Asistente:', ASSISTANT_TYPE);

        // Funci√≥n de utilidad para a√±adir headers de ngrok
        function getNgrokHeaders() {
            return {
                'ngrok-skip-browser-warning': 'true',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            };
        }

        // === Variables globales ===
        let sessionId = null;
        let conversationHistory = [];
        let isProcessing = false;
        let isServerAvailable = false;
        let currentStreamResponse = '';
        let currentMessageId = null;
        let isStreaming = false;

        // === Elementos DOM ===
        const statusElement = document.getElementById('status');
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const typingIndicator = document.getElementById('typingIndicator');
        const brandMini = document.getElementById('brandMini');
        const modeButtons = document.querySelectorAll('.seg button');
        const panelsContainer = document.getElementById('panels');

        // === Variables para parallax infinito ===
        let allPanels = [];
        let lastScrollY = window.scrollY || document.documentElement.scrollTop;

        // === Inicializaci√≥n ===
        document.addEventListener('DOMContentLoaded', () => {
            generateSessionId();
            loadFromLocalStorage();
            setupEventListeners();
            checkServerOnce();
            applyTheme('auto');
            initInfiniteParallaxPanels(); // Inicializar paneles parallax infinito
            
            // Debug
            console.log('üÜî Session ID:', sessionId);
            console.log('üìù Historial cargado:', conversationHistory.length, 'mensajes');
        });

        // === Sistema de sesi√≥n MEJORADO ===
        function generateSessionId() {
            // Intentar obtener de localStorage primero
            const storedId = localStorage.getItem('alex_session_id');
            
            if (storedId) {
                sessionId = storedId;
                console.log('üîÑ Session ID recuperado de localStorage:', sessionId);
            } else {
                // Crear un nuevo ID persistente
                sessionId = 'alex_' + Date.now() + '_' + Math.random().toString(36).substr(2, 12);
                localStorage.setItem('alex_session_id', sessionId);
                console.log('üÜï Nuevo Session ID creado:', sessionId);
            }
            
            // Tambi√©n guardar la fecha de creaci√≥n
            if (!localStorage.getItem('alex_session_created')) {
                localStorage.setItem('alex_session_created', new Date().toISOString());
            }
        }

        // === Tema ===
        function applyTheme(mode) {
            if (mode === 'auto') {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                document.body.dataset.theme = prefersDark ? 'dark' : 'light';
            } else {
                document.body.dataset.theme = mode;
            }
            localStorage.setItem('theme', mode);
        }

        modeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                modeButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                applyTheme(btn.dataset.mode);
            });
            
            const savedTheme = localStorage.getItem('theme') || 'auto';
            if (btn.dataset.mode === savedTheme) {
                btn.classList.add('active');
            }
        });

        // === SISTEMA PARALLAX INFINITO MEJORADO ===
        function initInfiniteParallaxPanels() {
            const rainbowColors = ['color-red', 'color-orange', 'color-yellow', 'color-green', 'color-blue', 'color-violet'];
            
            // Contenido mejorado para los paneles
            const panelContents = {
                large: [
                    { lines: ['// Inicializando sistema...', 'const user = "t√∫";', 'const assistant = "Alex";', 'function startChat() {', '  return "Hola, ¬øc√≥mo est√°s?";', '}', 'console.log(startChat());'] },
                    { lines: ['<system_init/>', 'LOADING emotional_support.ai', 'MODEL: llama3.2:3b', 'STATUS: online', 'READY: listening...', 'boot> COMPLETE'] },
                    { lines: ['// Conexi√≥n establecida', 'const session = new Session();', 'session.user = getUser();', 'session.assistant = "Alex";', 'session.startTime = now();', 'log("Session started");'] },
                    { lines: ['class EmotionalSupport {', '  constructor() {', '    this.empathy = true;', '    this.active = true;', '    this.listening = true;', '  }', '  respond(query) {', '    return generateResponse(query);', '  }', '}'] }
                ],
                medium: [
                    { lines: ['// Configuraci√≥n API', 'const config = {', '  endpoint: "/chat",', '  model: "llama3.2:3b",', '  stream: true,', '  temperature: 0.7', '}', 'export default config;'] },
                    { lines: ['func analyzeMood() {', '  let emotions = ["happy", "sad", "anxious"]', '  let intensity = 0.7', '  return processEmotions(emotions)', '}', 'result = analyzeMood()'] },
                    { lines: ['public class SupportBot {', '  private String name = "Alex";', '  public String respondTo(String message) {', '    return generateEmpatheticResponse(message);', '  }', '  public boolean isAvailable() {', '    return true;', '  }', '}'] },
                    { lines: ['-- Base de datos emociones', 'CREATE TABLE conversations (', '  id INT PRIMARY KEY,', '  message TEXT,', '  emotion VARCHAR(50),', '  timestamp DATETIME', ');', 'INSERT INTO conversations VALUES (1, "Hola", "neutral", NOW());'] },
                    { lines: ['import SwiftUI', 'struct ChatView: View {', '  @State var messages: [Message]', '  var body: some View {', '    List(messages) { message in', '      MessageRow(message: message)', '    }', '  }', '}'] }
                ],
                small: [
                    { lines: ['npm install empathy-engine', '‚úì Dependencies installed', 'build: successful'] },
                    { lines: ['git commit -m', '"feat: emotional support"', 'push origin main'] },
                    { lines: ['DEBUG MODE', 'Processing: user_input', 'Generating: response'] },
                    { lines: ['CPU: 12% load', 'MEM: 1.2GB used', 'NET: 85kb/s'] },
                    { lines: ['test_response.py running', '‚úì 18/18 tests passed', 'coverage: 95%'] },
                    { lines: ['docker build -t alex', 'image: alex:latest', 'container: running'] }
                ]
            };
            
            // Crear paneles iniciales
            createInitialPanels(panelContents, rainbowColors);
            
            // Configurar el sistema de reciclaje infinito
            setupInfiniteParallax();
        }
        
        function createInitialPanels(panelContents, rainbowColors) {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Crear paneles grandes (2)
            for (let i = 0; i < 2; i++) {
                const content = panelContents.large[i % panelContents.large.length];
                const panel = createPanel('large', content, rainbowColors[i % rainbowColors.length], viewportWidth, viewportHeight);
                allPanels.push(panel);
            }
            
            // Crear paneles medianos (3)
            for (let i = 0; i < 3; i++) {
                const content = panelContents.medium[i % panelContents.medium.length];
                const panel = createPanel('medium', content, rainbowColors[(i + 2) % rainbowColors.length], viewportWidth, viewportHeight);
                allPanels.push(panel);
            }
            
            // Crear paneles peque√±os (4)
            for (let i = 0; i < 4; i++) {
                const content = panelContents.small[i % panelContents.small.length];
                const panel = createPanel('small', content, rainbowColors[(i + 5) % rainbowColors.length], viewportWidth, viewportHeight);
                allPanels.push(panel);
            }
        }
        
        function createPanel(type, content, colorClass, viewportWidth, viewportHeight) {
            const panel = document.createElement('div');
            
            // Determinar dimensiones seg√∫n tipo
            let width, height;
            switch(type) {
                case 'large': width = 280; height = 140; break;
                case 'medium': width = 220; height = 110; break;
                case 'small': width = 150; height = 75; break;
            }
            
            // Ajustar para m√≥viles
            if (window.innerWidth <= 768) {
                width *= 0.8;
                height *= 0.8;
            }
            
            panel.className = `panel ${type} ${colorClass}`;
            panel.style.width = `${width}px`;
            panel.style.height = `${height}px`;
            
            // Posici√≥n inicial aleatoria
            const left = Math.random() * (viewportWidth - width);
            const top = Math.random() * (viewportHeight - height);
            
            panel.style.left = `${left}px`;
            panel.style.top = `${top}px`;
            
            // Crear contenido interno
            const inner = document.createElement('div');
            inner.className = 'inner';
            panel.appendChild(inner);
            
            // Agregar al contenedor
            panelsContainer.appendChild(panel);
            
            // Crear objeto panel para control
            const panelObj = {
                el: panel,
                type: type,
                content: content,
                width: width,
                height: height,
                speed: getSpeedForType(type),
                animationId: null,
                currentLine: 0
            };
            
            // Iniciar animaci√≥n de texto
            startPanelTextAnimation(panelObj);
            
            return panelObj;
        }
        
        function getSpeedForType(type) {
            switch(type) {
                case 'large': return 0.3;
                case 'medium': return 0.5;
                case 'small': return 0.7;
                default: return 0.5;
            }
        }
        
        function startPanelTextAnimation(panelObj) {
            const inner = panelObj.el.querySelector('.inner');
            let lineIndex = 0;
            let charIndex = 0;
            let isDeleting = false;
            let currentText = '';
            
            function type() {
                if (!panelObj.content || !panelObj.content.lines || panelObj.content.lines.length === 0) {
                    // Contenido vac√≠o, mostrar placeholder
                    inner.innerHTML = '<div class="code-line">// Cargando...</div>';
                    return;
                }
                
                const fullText = panelObj.content.lines[lineIndex];
                
                if (isDeleting) {
                    currentText = fullText.substring(0, charIndex - 1);
                    charIndex--;
                } else {
                    currentText = fullText.substring(0, charIndex + 1);
                    charIndex++;
                }
                
                inner.innerHTML = `<div class="code-line">${currentText}<span class="typing-cursor"></span></div>`;
                
                let typeSpeed = isDeleting ? 50 : 100;
                
                // Si completamos una l√≠nea
                if (!isDeleting && charIndex === fullText.length) {
                    typeSpeed = 2000; // Pausa al final de la l√≠nea
                    isDeleting = true;
                } else if (isDeleting && charIndex === 0) {
                    isDeleting = false;
                    lineIndex = (lineIndex + 1) % panelObj.content.lines.length;
                }
                
                panelObj.animationId = setTimeout(type, typeSpeed);
            }
            
            // Limpiar animaci√≥n previa si existe
            if (panelObj.animationId) {
                clearTimeout(panelObj.animationId);
            }
            
            type();
        }
        
        // === SISTEMA DE RECICLAJE INFINITO MEJORADO ===
        function setupInfiniteParallax() {
            let ticking = false;
            
            // Funci√≥n para actualizar posiciones y reciclar paneles
            function updateParallax() {
                const scrollY = window.scrollY || document.documentElement.scrollTop;
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                
                // Calcular direcci√≥n del scroll
                const scrollDirection = scrollY > lastScrollY ? 'down' : 'up';
                lastScrollY = scrollY;
                
                allPanels.forEach(panel => {
                    if (!panel.el) return;
                    
                    const rect = panel.el.getBoundingClientRect();
                    const currentTop = parseFloat(panel.el.style.top) || 0;
                    
                    // Aplicar efecto parallax basado en la direcci√≥n
                    let newTop = currentTop;
                    const speedMultiplier = 0.5; // Reducir velocidad para mejor control
                    
                    if (scrollDirection === 'down') {
                        newTop = currentTop - (panel.speed * speedMultiplier);
                    } else {
                        newTop = currentTop + (panel.speed * speedMultiplier);
                    }
                    
                    panel.el.style.top = `${newTop}px`;
                    
                    // Verificar si el panel est√° fuera de la pantalla
                    const isAboveViewport = rect.bottom < -50;
                    const isBelowViewport = rect.top > viewportHeight + 50;
                    
                    // Reciclar panel si est√° fuera de la pantalla
                    if (isAboveViewport || isBelowViewport) {
                        recyclePanel(panel, isAboveViewport, viewportWidth, viewportHeight);
                    }
                });
                
                ticking = false;
            }
            
            // Funci√≥n para reciclar un panel
            function recyclePanel(panel, isAboveViewport, viewportWidth, viewportHeight) {
                // Detener animaci√≥n actual
                if (panel.animationId) {
                    clearTimeout(panel.animationId);
                    panel.animationId = null;
                }
                
                // Determinar nueva posici√≥n
                let newTop, newLeft;
                
                if (isAboveViewport) {
                    // Si est√° arriba, moverlo abajo
                    newTop = viewportHeight + 50;
                } else {
                    // Si est√° abajo, moverlo arriba
                    newTop = -panel.height - 50;
                }
                
                // Nueva posici√≥n horizontal aleatoria
                newLeft = Math.random() * (viewportWidth - panel.width);
                
                // Aplicar nueva posici√≥n
                panel.el.style.top = `${newTop}px`;
                panel.el.style.left = `${newLeft}px`;
                
                // Reiniciar animaci√≥n de texto despu√©s de un breve retraso
                setTimeout(() => {
                    startPanelTextAnimation(panel);
                }, 100);
            }
            
            // Event listener para scroll - optimizado
            window.addEventListener('scroll', () => {
                if (!ticking) {
                    window.requestAnimationFrame(updateParallax);
                    ticking = true;
                }
            });
            
            // Event listener para resize
            window.addEventListener('resize', () => {
                // Ajustar paneles al nuevo tama√±o de ventana
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                allPanels.forEach(panel => {
                    if (!panel.el) return;
                    
                    const currentLeft = parseFloat(panel.el.style.left) || 0;
                    const currentTop = parseFloat(panel.el.style.top) || 0;
                    
                    // Asegurarse de que los paneles est√©n dentro de los l√≠mites
                    if (currentLeft > viewportWidth || currentLeft < -panel.width) {
                        panel.el.style.left = `${Math.random() * (viewportWidth - panel.width)}px`;
                    }
                    
                    if (currentTop > viewportHeight * 2 || currentTop < -panel.height * 2) {
                        panel.el.style.top = `${Math.random() * viewportHeight}px`;
                    }
                });
            });
            
            // Iniciar movimiento continuo suave
            let animationId = null;
            
            function smoothParallax() {
                const scrollY = window.scrollY || document.documentElement.scrollTop;
                
                allPanels.forEach(panel => {
                    if (!panel.el) return;
                    
                    const currentTop = parseFloat(panel.el.style.top) || 0;
                    // Movimiento suave continuo (m√°s lento que con scroll)
                    const newTop = currentTop - (panel.speed * 0.1);
                    panel.el.style.top = `${newTop}px`;
                    
                    // Reciclar si es necesario
                    const rect = panel.el.getBoundingClientRect();
                    const viewportHeight = window.innerHeight;
                    
                    if (rect.bottom < -100 || rect.top > viewportHeight + 100) {
                        const viewportWidth = window.innerWidth;
                        recyclePanel(panel, rect.bottom < -100, viewportWidth, viewportHeight);
                    }
                });
                
                animationId = requestAnimationFrame(smoothParallax);
            }
            
            // Iniciar animaci√≥n continua
            smoothParallax();
            
            // Limpiar al desmontar
            return () => {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            };
        }

        // === Verificaci√≥n del servidor ===
        async function checkServerOnce() {
            try {
                updateStatus('connecting', 'Conectando...');
                
                const response = await fetch(`${OLLAMA_SERVER_URL}/health`, {
                    method: 'GET',
                    headers: getNgrokHeaders()
                });
                
                if (response.ok) {
                    const data = await response.json();
                    isServerAvailable = true;
                    updateStatus('online', '‚úÖ Conectado');
                    console.log('‚úÖ Servidor funcionando:', data);
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('‚ùå Error de conexi√≥n inicial:', error);
                isServerAvailable = false;
                updateStatus('offline', '‚ö†Ô∏è Servidor no disponible');
                messageInput.placeholder = 'Servidor offline';
            }
        }

        // === ENV√çO DE MENSAJES CON STREAMING MEJORADO ===
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message || isProcessing) {
                console.log('No se puede enviar: mensaje vac√≠o o procesando');
                return;
            }
            
            console.log('üì§ Enviando mensaje a Alex:', message);
            console.log('üÜî Session ID:', sessionId);
            console.log('ü§ñ Assistant:', ASSISTANT_TYPE);
            
            // Agregar mensaje del usuario al chat
            addMessage('user', message);
            messageInput.value = '';
            messageInput.style.height = 'auto';
            saveToLocalStorage();
            
            // Deshabilitar entrada mientras se procesa
            isProcessing = true;
            isStreaming = true;
            sendBtn.disabled = true;
            messageInput.disabled = true;
            messageInput.placeholder = 'Alex est√° pensando...';
            
            // Crear elemento para la respuesta en streaming
            currentMessageId = 'msg_' + Date.now();
            createStreamingMessageElement(currentMessageId);
            currentStreamResponse = '';
            
            // Verificar servidor antes de enviar
            if (!isServerAvailable) {
                try {
                    const healthCheck = await fetch(`${OLLAMA_SERVER_URL}/health`, {
                        headers: getNgrokHeaders()
                    });
                    
                    if (healthCheck.ok) {
                        isServerAvailable = true;
                        updateStatus('online', '‚úÖ Reconectado');
                    }
                } catch (e) {
                    // Continuar con estado offline
                }
            }
            
            if (!isServerAvailable) {
                console.log('Servidor no disponible');
                finishStreamingWithError(currentMessageId, 'El servidor no est√° disponible. Intenta m√°s tarde.');
                return;
            }
            
            try {
                // Usar streaming con fetch y ReadableStream
                console.log('üåê Iniciando stream al servidor...');
                
                const response = await fetch(`${OLLAMA_SERVER_URL}/chat`, {
                    method: 'POST',
                    headers: getNgrokHeaders(),
                    body: JSON.stringify({
                        message: message,
                        assistant: ASSISTANT_TYPE,
                        session_id: sessionId,
                        stream: true
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Error ${response.status}: ${response.statusText}`);
                }
                
                // Leer el stream de respuesta
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                let hasFinished = false;
                
                try {
                    while (isStreaming) {
                        const { done, value } = await reader.read();
                        if (done) {
                            console.log('‚úÖ Stream terminado normalmente');
                            if (!hasFinished) {
                                finishStreamingSuccessfully(currentMessageId, currentStreamResponse, message);
                                hasFinished = true;
                            }
                            break;
                        }
                        
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n\n');
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    
                                    if (data.error) {
                                        throw new Error(data.error);
                                    }
                                    
                                    if (data.token) {
                                        currentStreamResponse += data.token;
                                        updateStreamingMessage(currentMessageId, currentStreamResponse, false);
                                    }
                                    
                                    if (data.done) {
                                        console.log('‚úÖ Recibido evento done del servidor');
                                        if (!hasFinished) {
                                            finishStreamingSuccessfully(currentMessageId, currentStreamResponse, message);
                                            hasFinished = true;
                                        }
                                        reader.cancel();
                                        return;
                                    }
                                } catch (e) {
                                    console.warn('‚ö†Ô∏è Error parseando l√≠nea:', line, e);
                                }
                            }
                        }
                    }
                } catch (streamError) {
                    console.error('‚ùå Error en lectura de stream:', streamError);
                    if (!hasFinished) {
                        finishStreamingWithError(currentMessageId, `Error de stream: ${streamError.message}`);
                        hasFinished = true;
                    }
                } finally {
                    reader.cancel().catch(() => {});
                }
                
            } catch (error) {
                console.error('‚ùå Error en fetch:', error);
                if (currentStreamResponse && currentStreamResponse.trim()) {
                    finishStreamingSuccessfully(currentMessageId, currentStreamResponse, message);
                } else {
                    finishStreamingWithError(currentMessageId, `Error: ${error.message}`);
                }
            }
        }

        // === Funciones para manejar streaming ===
        function createStreamingMessageElement(messageId) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message';
            messageDiv.id = messageId;
            
            const now = new Date();
            const timeString = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <div class="message-avatar">A</div>
                    <span>Alex</span>
                    <span class="message-time">${timeString}</span>
                </div>
                <div class="message-content streaming-text" id="${messageId}_content">
                    <span class="streaming-cursor"></span>
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            scrollChatToBottom();
        }

        function updateStreamingMessage(messageId, content, isComplete = false) {
            const contentElement = document.getElementById(`${messageId}_content`);
            if (contentElement) {
                contentElement.innerHTML = formatMessage(content);
                
                if (!isComplete) {
                    contentElement.innerHTML += '<span class="streaming-cursor"></span>';
                }
                
                scrollChatToBottom();
            }
        }

        function finishStreamingSuccessfully(messageId, fullResponse, originalMessage) {
            console.log('‚úÖ Finalizando stream exitosamente');
            
            isStreaming = false;
            
            const contentElement = document.getElementById(`${messageId}_content`);
            if (contentElement) {
                contentElement.innerHTML = formatMessage(fullResponse);
            }
            
            conversationHistory.push({
                role: 'user',
                content: originalMessage,
                timestamp: new Date().toISOString()
            });
            
            conversationHistory.push({
                role: 'assistant',
                content: fullResponse,
                timestamp: new Date().toISOString()
            });
            
            if (conversationHistory.length > 20) {
                conversationHistory = conversationHistory.slice(-20);
            }
            
            saveToLocalStorage();
            restoreInterface();
            updateStatus('online', '‚úÖ Conectado');
            
            // Scroll final despu√©s de que todo est√© completo
            setTimeout(scrollChatToBottom, 100);
        }

        function finishStreamingWithError(messageId, errorMessage) {
            console.log('‚ùå Finalizando stream con error:', errorMessage);
            
            isStreaming = false;
            
            const contentElement = document.getElementById(`${messageId}_content`);
            if (contentElement) {
                contentElement.innerHTML = `<span style="color: #ff5555;">${errorMessage}</span>`;
            }
            
            restoreInterface();
            updateStatus('offline', '‚ö†Ô∏è Error de conexi√≥n');
            scrollChatToBottom();
        }

        // === Funci√≥n para hacer scroll autom√°tico en el chat ===
        function scrollChatToBottom() {
            // Usar setTimeout para asegurar que el DOM se haya actualizado
            setTimeout(() => {
                chatMessages.scrollTo({
                    top: chatMessages.scrollHeight,
                    behavior: 'smooth'
                });
            }, 10);
        }

        // === Funci√≥n para restaurar la interfaz ===
        function restoreInterface() {
            console.log('üîÑ Restaurando interfaz...');
            isProcessing = false;
            sendBtn.disabled = false;
            messageInput.disabled = false;
            messageInput.placeholder = '';
            messageInput.focus();
            
            sendBtn.style.opacity = '1';
        }

        // === Funciones para manejar mensajes normales ===
        function addMessage(role, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}-message`;
            
            const now = new Date();
            const timeString = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            
            const avatar = role === 'user' ? 'T' : 'A';
            const name = role === 'user' ? 'T√∫' : 'Alex';
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <div class="message-avatar">${avatar}</div>
                    <span>${name}</span>
                    <span class="message-time">${timeString}</span>
                </div>
                <div class="message-content">
                    ${formatMessage(content)}
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            
            const welcomeMessage = document.querySelector('.welcome-message');
            if (welcomeMessage) {
                welcomeMessage.remove();
            }
            
            scrollChatToBottom();
        }

        // === Actualizar estado ===
        function updateStatus(status, text) {
            statusElement.textContent = text;
            statusElement.className = 'status-indicator';
            
            switch(status) {
                case 'online':
                    statusElement.classList.add('online');
                    break;
                case 'offline':
                    statusElement.classList.add('offline');
                    break;
                case 'connecting':
                    statusElement.classList.add('connecting');
                    break;
            }
        }

        // === Formatear mensajes ===
        function formatMessage(text) {
            if (!text) return '';
            
            let formatted = text;
            
            formatted = formatted.replace(
                /(https?:\/\/[^\s]+)/g, 
                '<a href="$1" target="_blank" rel="noopener noreferrer" style="color: var(--accent-color); text-decoration: none; border-bottom: 1px dotted;">$1</a>'
            );
            
            formatted = formatted.replace(/`([^`]+)`/g, '<code style="background: rgba(0,0,0,0.1); padding: 2px 4px; border-radius: 3px; font-family: var(--mono); font-size: 0.9em;">$1</code>');
            
            formatted = formatted.replace(/```(\w+)?\n([\s\S]*?)```/g, function(match, lang, code) {
                return `<pre style="background: rgba(0,0,0,0.1); padding: 8px; border-radius: 6px; overflow-x: auto; margin: 8px 0; border: 1px solid rgba(255,255,255,0.1);"><code>${code.trim()}</code></pre>`;
            });
            
            formatted = formatted.replace(/\n/g, '<br>');
            formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            formatted = formatted.replace(/\*([^*]+)\*/g, '<em>$1</em>');
            
            return formatted;
        }

        // === LocalStorage ===
        function saveToLocalStorage() {
            const chatData = {
                sessionId: sessionId,
                assistant: ASSISTANT_TYPE,
                messages: conversationHistory,
                lastUpdated: new Date().toISOString()
            };
            localStorage.setItem('chatData_alex', JSON.stringify(chatData));
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('chatData_alex');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    
                    if (data.sessionId === sessionId || 
                        (new Date() - new Date(data.lastUpdated)) < 86400000) {
                        
                        conversationHistory = data.messages || [];
                        
                        const welcomeMessage = document.querySelector('.welcome-message');
                        if (welcomeMessage && conversationHistory.length > 0) {
                            welcomeMessage.remove();
                        }
                        
                        conversationHistory.forEach(msg => {
                            const messageDiv = document.createElement('div');
                            messageDiv.className = `message ${msg.role}-message`;
                            
                            const time = new Date(msg.timestamp);
                            const timeString = time.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                            const avatar = msg.role === 'user' ? 'T' : 'A';
                            const name = msg.role === 'user' ? 'T√∫' : 'Alex';
                            
                            messageDiv.innerHTML = `
                                <div class="message-header">
                                    <div class="message-avatar">${avatar}</div>
                                    <span>${name}</span>
                                    <span class="message-time">${timeString}</span>
                                </div>
                                <div class="message-content">
                                    ${formatMessage(msg.content)}
                                </div>
                            `;
                            
                            chatMessages.appendChild(messageDiv);
                        });
                        
                        scrollChatToBottom();
                    }
                } catch (e) {
                    console.error('‚ùå Error cargando datos:', e);
                }
            }
        }

        // === Configurar event listeners ===
        function setupEventListeners() {
            // Enter para enviar, Shift+Enter para nueva l√≠nea
            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            
            // Auto-expandir textarea
            messageInput.addEventListener('input', () => {
                messageInput.style.height = 'auto';
                const newHeight = Math.min(messageInput.scrollHeight, 150);
                messageInput.style.height = newHeight + 'px';
            });
            
            // Auto-focus al cargar
            setTimeout(() => {
                messageInput.focus();
            }, 500);
            
            // Limpiar historial con doble click en el t√≠tulo
            document.querySelector('.chat-title').addEventListener('dblclick', () => {
                if (confirm('¬øDeseas limpiar todo el historial de conversaci√≥n?\n\nEsto eliminar√° todos los mensajes visuales y reiniciar√° la sesi√≥n.')) {
                    localStorage.removeItem('chatData_alex');
                    localStorage.removeItem('alex_session_id');
                    localStorage.removeItem('alex_session_created');
                    
                    conversationHistory = [];
                    generateSessionId();
                    
                    const messages = chatMessages.querySelectorAll('.message');
                    messages.forEach(msg => msg.remove());
                    
                    if (!document.querySelector('.welcome-message')) {
                        const welcomeDiv = document.createElement('div');
                        welcomeDiv.className = 'welcome-message';
                        welcomeDiv.innerHTML = `
                            <h2>Hola, soy Alex üëã</h2>
                            <p>Estoy aqu√≠ para ofrecerte un espacio seguro de conversaci√≥n. Puedes contarme c√≥mo te sientes, compartir tus pensamientos, o simplemente charlar. Mi objetivo es escucharte con empat√≠a y ofrecerte apoyo emocional. ¬øC√≥mo ha sido tu d√≠a hasta ahora?</p>
                        `;
                        chatMessages.prepend(welcomeDiv);
                    }
                    
                    messageInput.focus();
                    updateStatus('online', '‚úÖ Sesi√≥n reiniciada');
                    
                    console.log('üîÑ Sesi√≥n reiniciada, nuevo Session ID:', sessionId);
                }
            });
            
            // Animaci√≥n del logo
            brandMini.addEventListener('click', () => {
                brandMini.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    brandMini.style.transform = 'scale(1.1)';
                }, 100);
                setTimeout(() => {
                    brandMini.style.transform = 'scale(1)';
                }, 200);
            });
            
            // Prevenir env√≠o m√∫ltiple
            sendBtn.addEventListener('click', (e) => {
                if (isProcessing) {
                    e.preventDefault();
                    return false;
                }
            });
            
            // Verificar conexi√≥n peri√≥dicamente
            setInterval(() => {
                if (!isServerAvailable && !isProcessing) {
                    checkServerOnce();
                }
            }, 30000);
        }

        // === Funci√≥n para forzar restauraci√≥n de interfaz ===
        function forceRestoreInterface() {
            console.log('üõ†Ô∏è Forzando restauraci√≥n de interfaz...');
            isProcessing = false;
            isStreaming = false;
            sendBtn.disabled = false;
            messageInput.disabled = false;
            messageInput.placeholder = '';
            messageInput.focus();
            updateStatus('online', '‚úÖ Listo');
        }
        
        // Hacer la funci√≥n disponible globalmente para debugging
        window.forceRestoreInterface = forceRestoreInterface;
        window.debugInfo = () => {
            return {
                sessionId,
                conversationHistoryLength: conversationHistory.length,
                isServerAvailable,
                isProcessing,
                isStreaming
            };
        };
        
        // Mostrar informaci√≥n de depuraci√≥n en consola
        console.log('üîç Debug info disponible: window.debugInfo()');
        console.log('üõ†Ô∏è  Force restore disponible: window.forceRestoreInterface()');
    </script>
</body>
</html>
